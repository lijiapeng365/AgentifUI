import { create } from 'zustand';

/**
 * Message attachment data structure
 */
export interface MessageAttachment {
  /** Attachment ID */
  id: string;
  /** File name */
  name: string;
  /** File size (bytes) */
  size: number;
  /** MIME type */
  type: string;
  /** Uploaded file ID */
  upload_file_id: string;
  /** Dify application ID for API calls (optional for backward compatibility) */
  app_id?: string;
}

/**
 * Chat message data structure
 * @description Contains basic message info and persistence-related fields
 */
export interface ChatMessage {
  /** Unique message ID (generated by frontend) */
  id: string;
  /** Message content */
  text: string;
  /** Whether this is a user message */
  isUser: boolean;
  /** Whether the assistant message is still streaming */
  isStreaming?: boolean;
  /** Whether the message was manually stopped by the user */
  wasManuallyStopped?: boolean;
  /** Error info related to the message */
  error?: string | null;
  /** File attachments associated with the message */
  attachments?: MessageAttachment[];
  /** Message sequence index, 0=user, 1=assistant, 2=system, etc. */
  sequence_index?: number;

  /** Database message ID, only available after successful save */
  db_id?: string;
  /** Message persistence status, for UI display */
  persistenceStatus?: 'pending' | 'saving' | 'saved' | 'error';
  /** Message role, consistent with database */
  role?: 'user' | 'assistant' | 'system';
  /** Dify message ID, for associating with external messages */
  dify_message_id?: string;
  /** Token count, for billing or statistics */
  token_count?: number;
  /** Metadata, stores additional info */
  metadata?: Record<string, unknown>;
}

/**
 * Chat state management interface
 */
interface ChatState {
  /** Complete message list */
  messages: ChatMessage[];
  /** Currently streaming assistant message ID, null means no ongoing stream */
  streamingMessageId: string | null;
  /** Whether waiting for API response (before stream starts or for non-streaming response) */
  isWaitingForResponse: boolean;
  /** Current active conversation unique identifier, null means a new conversation */
  currentConversationId: string | null;
  /** Current streaming task ID, from Dify streaming response */
  currentTaskId: string | null;

  /**
   * Add a new message to the list
   * @param messageData Message data (excluding ID)
   * @returns The added message object (with generated ID)
   */
  addMessage: (messageData: Omit<ChatMessage, 'id'>) => ChatMessage;

  /**
   * Append a text chunk to the message with the specified ID (for streaming output)
   * @param id Message ID
   * @param chunk Text chunk to append
   */
  appendMessageChunk: (id: string, chunk: string) => void;

  /**
   * Mark the message with the specified ID as streaming complete
   * @param id Message ID
   */
  finalizeStreamingMessage: (id: string) => void;

  /**
   * Mark the message as manually stopped
   * @param id Message ID
   */
  markAsManuallyStopped: (id: string) => void;

  /**
   * Set the error state for the message with the specified ID
   * @param id Message ID
   * @param error Error info, null to clear error
   */
  setMessageError: (id: string, error: string | null) => void;

  /**
   * Clear all messages
   */
  clearMessages: () => void;

  /**
   * Set whether waiting for API response
   * @param status Waiting status
   */
  setIsWaitingForResponse: (status: boolean) => void;

  /**
   * Set/update current conversation ID
   * @param conversationId Conversation ID, null means new conversation
   */
  setCurrentConversationId: (conversationId: string | null) => void;

  /**
   * Set/update current streaming task ID
   * @param taskId Task ID, null means no ongoing task
   */
  setCurrentTaskId: (taskId: string | null) => void;

  /**
   * Update specific properties of a message
   * @param id Message ID
   * @param updates Properties to update
   */
  updateMessage: (
    id: string,
    updates: Partial<Omit<ChatMessage, 'id' | 'isUser'>>
  ) => void;
}

/**
 * Chat state management store
 * @description Uses Zustand to manage chat-related state and actions
 */
export const useChatStore = create<ChatState>(set => ({
  // Initial state
  messages: [],
  streamingMessageId: null,
  isWaitingForResponse: false,
  currentConversationId: null,
  currentTaskId: null,

  // Action implementations
  addMessage: messageData => {
    const id = `msg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    const newMessage = { id, ...messageData };

    set(state => ({
      messages: [...state.messages, newMessage],
      streamingMessageId: messageData.isStreaming
        ? id
        : state.streamingMessageId,
    }));

    return newMessage;
  },

  appendMessageChunk: (id, chunk) => {
    set(state => ({
      messages: state.messages.map(message =>
        message.id === id ? { ...message, text: message.text + chunk } : message
      ),
    }));
  },

  finalizeStreamingMessage: id => {
    set(state => ({
      messages: state.messages.map(message =>
        message.id === id ? { ...message, isStreaming: false } : message
      ),
      streamingMessageId:
        state.streamingMessageId === id ? null : state.streamingMessageId,
    }));
  },

  markAsManuallyStopped: id => {
    set(state => ({
      messages: state.messages.map(message =>
        message.id === id
          ? { ...message, wasManuallyStopped: true, isStreaming: false }
          : message
      ),
      streamingMessageId:
        state.streamingMessageId === id ? null : state.streamingMessageId,
    }));
  },

  setMessageError: (id, error) => {
    set(state => ({
      messages: state.messages.map(message =>
        message.id === id ? { ...message, error } : message
      ),
    }));
  },

  clearMessages: () => {
    set(() => ({
      messages: [],
      streamingMessageId: null,
    }));
  },

  setIsWaitingForResponse: status => {
    set(() => ({
      isWaitingForResponse: status,
    }));
  },

  setCurrentConversationId: conversationId => {
    set(() => ({
      currentConversationId: conversationId,
    }));
  },

  setCurrentTaskId: taskId => {
    set(() => ({
      currentTaskId: taskId,
    }));
  },

  updateMessage: (id, updates) => {
    set(state => ({
      messages: state.messages.map(message =>
        message.id === id ? { ...message, ...updates } : message
      ),
    }));
  },
}));

/**
 * Get whether the chat is currently processing (waiting for response or streaming)
 */
export const selectIsProcessing = (state: ChatState): boolean =>
  state.isWaitingForResponse || state.streamingMessageId !== null;
